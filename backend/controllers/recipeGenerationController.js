import asyncHandler from 'express-async-handler';
import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';
import Recipe from '../models/recipeModel.js';
import axios from 'axios';

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Python service URL
const PYTHON_SERVICE_URL = 'http://localhost:5001/predict';

// Function to call the Python service
const callPythonService = async (ingredients) => {
  console.log('Calling Python service for recipe generation...');
  
  try {
    // Make HTTP request to Python service
    const response = await axios.post(PYTHON_SERVICE_URL, { ingredients });
    console.log(response);
    // 游릭 IMPORTANT: Destructure the expected fields from the successful response 游릭
    const { title, directions, ingredients: returnedIngredients, NER } = response.data;

    // Return the required structured data
    return { title, directions, returnedIngredients, NER };

  } catch (error) {
    console.error('Error calling Python service:', error.message);
    
    // 游릭 UPDATED Fallback structure to match the fields saved to the DB 游릭
    return {
      title: `Fallback: Dish with ${ingredients.slice(0, 3).join(', ')}`,
      returnedIngredients: ingredients,
      directions: `1. Combine ${ingredients.join(', ')} in a bowl.\n2. Cook until done.\n3. Serve hot.`,
      NER: [{ entity: 'Fallback', label: 'GENERIC' }] // Provide a default NER field
    };
  }
};

// @desc      Generate a recipe from ingredients
// @route     POST /api/recipes/generate
// @access    Private
const generateRecipe = asyncHandler(async (req, res) => {
  const { ingredients } = req.body;
  
  if (!ingredients || !Array.isArray(ingredients) || ingredients.length === 0) {
    res.status(400);
    throw new Error('Please provide a list of ingredients');
  }

  try {
    // Call the Python service
    const generatedData = await callPythonService(ingredients); // Renamed variable for clarity
    
    // Create a new recipe in the database
    const recipe = new Recipe({
      user: req.user._id,
      title: generatedData.title,
      description: `Generated recipe using: ${ingredients.join(', ')} (NER tags: ${generatedData.NER.map(e => e.label).join(', ')})`,
      ingredients: generatedData.returnedIngredients,
      instructions: generatedData.directions, // 游릭 FIXED: Use 'directions' for 'instructions' 游릭
      prepTime: 30,
      cookTime: 30,
      servings: 4,
      difficulty: 'Medium',
      cuisine: 'Mixed',
      tags: ['AI-generated', ...ingredients.slice(0, 5)],
      // 游릭 ADDED: Store the NER results in the notes/metadata field 游릭
      notes: `This recipe was generated by AI. NER results: ${JSON.stringify(generatedData.NER)}`, 
      isPublic: false
    });
    
    const savedRecipe = await recipe.save();
    
    res.status(201).json({
      ...savedRecipe._doc,
      // 游릭 REMOVED: rawResponse field is no longer returned by the Python service 游릭
      NER: generatedData.NER // Include NER results in the response to the client
    });
  } catch (error) {
    console.error('Recipe generation error:', error);
    res.status(500);
    throw new Error('Failed to generate recipe: ' + error.message);
  }
});

// @desc      Parse ingredients from text
// @route     POST /api/recipe-generation/parse-ingredients
// @access    Private
const parseIngredientsFromText = asyncHandler(async (req, res) => {
  const { text } = req.body;
  
  if (!text || typeof text !== 'string' || text.trim() === '') {
    res.status(400);
    throw new Error('Please provide a non-empty text to parse');
  }
  
  try {
    // Simple parsing logic - split by commas, newlines, or semicolons
    const ingredients = text
      .split(/[,;\n]/)
      .map(item => item.trim())
      .filter(item => item.length > 0);
    
    res.status(200).json({ ingredients });
  } catch (error) {
    console.error('Ingredient parsing error:', error);
    res.status(500);
    throw new Error('Failed to parse ingredients: ' + error.message);
  }
});

export { generateRecipe, parseIngredientsFromText };